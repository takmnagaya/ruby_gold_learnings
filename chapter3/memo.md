# Chapter3

## 識別子
クラス名や変数名を構成する文法の基本

### 命名規則
- 最初の文字列に数字は使用できない
- アンダースコア以外の記号は使用できない
- 予約語は変数名に使用できない

予約語
```
nil
true
false
not
or
and
....
```

### 変数と定数のスコープ
宣言可能な定数と変数

|種類|命名規則|スコープ|初期化していない場合に参照した場合の動作|
|---|---|---|---|
|ローカル変数|先頭は英小文字or_  構成文字は英数字と_|代入式が使用された位置から  ブロックorメソッドの終わりまで|代入文が記載されているが実行されなかったらnil  代入文がない場合は例外発生|
|グローバル変数|先頭$  構成文字は英数字or_|どこからでも参照可能|nil|
|クラス変数|先頭@@  構成文字は英数字or_|そのクラスの全インスタンスから参照可能|例外発生|
|インスタンス変数|先頭@  構成文字は英数字or_|そのインスタンスから参照可能|nil|
|定数|先頭大文字  英数字or_|定数が定義されたモジュール、クラス内  そのクラスの内側で定義されたクラス、モジュール内  そのクラスを継承、インクルードしているモジュール内  クラス名やモジュール名で修飾すれば外部からアクセス可能|例外発生|

### Rubyのリテラル
- 文字列
- 数値
- 配列
- ハッシュ
- 論理値
- シンボル
- 範囲
- コマンド出力
- 正規表現

### 数値
#### 基数指示子
- 0b 2進数
- 0o or O 8進数
- 0d 10進数
- 0x 16進数

:warning: 小数や存在しない数値を指定すると構文エラーになる

数値リテラルで_を使用し、桁を見やすくすることができる。
```ruby
100_000_000
```

#### 有理数クラス、虚数クラス
```ruby
42/10r
3.14i
```

#### 数値演算
**UFO演算子**
```ruby
1 <=> 2 # => -1
2 <=> 1 # => 1
1 <=> 1 # => 0
```

**自己代入演算子**
```ruby
a = 100
a += 100 # => 200
a -= 100 # => 0
a *= 10 # => 1_000
a **= 2 # => 10_000
```

#### 再定義できない演算子
- :: スコープ演算子
- = 代入演算子
- ?: 条件演算子
- .. ... 範囲演算子
- and or || && not 論理演算子

これ以外の演算子はメソッドを使って再定義できる。

#### ?に続く文字のリテラル
```ruby
?R # => 文字「R」を表すString
?\C-v # => Ctrl + vを表すString
?\n # => 改行
```

### メソッド
```ruby
def hoge(a = 0) # a 仮引数
  a + 1
end

hoge(10) # 10 実引数
```

- 仮引数ではデフォルト値を指定できる。
- デフォルト値を足しても引数が足りない場合は`ArgumentError`になる。

#### キーワード引数
```ruby
def hoge(**args)
  # argsは任意の値をハッシュに格納できる
end
```

### 論理値
**`true`は真の代表値であり、`false`と`nil`以外のオブジェクトは全て真とみなされる**

:warning: if**式** case**式**なので値を返すことができる。
if修飾子も使用でき、条件判定の結果によらず、変数を確保することができる。(結果が偽であっても、ローカル変数は作成される)

### 擬似変数
nilやfalseなどの特殊な変数で、唯一のインスタンスを参照する。
**擬似変数には代入できない。**

その他擬似変数
```ruby
nil
true
false
self
__FILE__
__LINE__

```

### 論理演算子
&&(論理積) ||(論理和) !(否定)

**式の評価値は最後に評価した値となる**

#### and or notと && || !
Rubyの特徴的な演算子がand or notでそれぞれ&& || !に対応している。
違いとしては

- 自己代入できない
- 代入演算子よりも優先度が低いこと

### 文字列
- シングルクォートは文字列展開できない(`#{}`が使えない)
- ダブルクォートは文字列展開できる(`#{}`が使える)

#### ヒアドキュメントなど
rbファイル参照

%記法
- `%[]` []はアルファベット、数字以外の記号で置き換えられる！
- %q -> 式展開しない
- %Q -> 式展開する

#### sprintf
フォーマットに使用する
第一引数でフォーマットを、第二引数でフォーマットしたい値を渡す。

**進数(%#)と桁数(%0)の指定ができる**
```ruby
p sprintf("%#b", 16) # => 0b10000 2進数
p sprintf("%#o", 16) # => 020 8進数
p sprintf("%#x", 16) # => 0x10 16進数
p sprintf("%#d", 16) # => 16 10進数
```

```ruby
p sprintf('%02d', 2) # => 02
```
**文字列の%演算はsprintfと同じ結果になる**

### シンボル
#### シンボルの生成
```ruby
:aa
:'aa'
a = 'hogehoge'
:"#{a}aa"
%s(hoge)
```
**`%s`で生成可能！** 

文字列:arrow_right:シンボルの変換は`to_sym`メソッドで
シンボル:arrow_right:文字列の変換は`to_s`メソッドで

#### オブジェクトの同一性と同値性
同一性 :arrow_right: 同じオブジェクトであること
同値性 :arrow_right: 同じ値を持つこと

シンボルの場合同じリテラルで同一のオブジェクトになる => 同一ということはオブジェクトIDが同じ
文字列の場合、同じリテラルで同値のオブジェクトにはなるが、同一のオブジェクトにはならない

**単にラベルとして文字の列を扱いたい場合はシンボルを使ったほうが効率が良くなる**

- equal? 同じオブジェクトか？
- == 同じ値か？
- eql? 同じ値かつ同じクラスのインスタンスか？

#### 変数と値
**変数をコピーする際は参照先がコピーされるだけだが、代入の際にはほとんどの場合再代入になるので、元の変数には影響は与えない**

**ただし破壊的メソッドの場合は参照元の値も書き換えるので注意が必要**

### 配列
#### 初期化
```ruby
a = [1, 2, 3]
a = %w(a b c d)
a = Array.new(3) # => [nil, nil, nil]
a = Array.new(3, 1) # => [1, 1, 1] ただし全て同じオブジェクトを指すので注意!
a = Array.new(3) { 1 } # => [1, 1, 1] 全て異なるオブジェクト
```

#### 参照, 代入
要素数を指定した参照
```ruby
a = [0, 1, 2, 3, 4, 5]
a[2, 3] # => [2, 3, 4]
```

多重代入
```ruby
a, b, c = 1, 2, 3
def hoge
  return 1, 2
end
a, b = hoge
```
**可変長引数**
```ruby
a, b, *c = 1, 2, 3, 4
p a
p b
p c # => [3, 4]
```
**引数展開**
```ruby
def hoge(a, *b)
  p a
  p b
end
hoge(1, 2, 3, 4, 5)
```

#### 配列の演算
